\documentclass[a4paper]{article}
% \documentclass[twocolumn,12pt]{article}
\usepackage{hyperref}
\usepackage{noweb}
\usepackage{amsmath}
\usepackage[UKenglish]{datetime}
%\usepackage[UKenglish]{isodate}
\newdateformat{mydate}{\twodigit{\THEDAY}{} \monthname[\THEMONTH]{} \THEYEAR}
\noweboptions{longxref,alphasubpage,subscriptidents,subscriptquotedidents,longchunks}

% % Set up formatting to look more like a modern report than an old book.
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

% Default Geometry
% \usepackage[margin=0.5in]{geometry}
% \usepackage[margin=0.5in, paperwidth=14.15in, paperheight=11.25in]{geometry} % 1280 x 1024 Monitor reading
% \usepackage[margin=0.5in, paperwidth=16.5in, paperheight=9.25in]{geometry} % 1600 x 900 Monitor reading (ThinkPad)
% \usepackage[margin=0.5in, paperwidth=19.9in, paperheight=11.1in]{geometry} % 1920 x 1080 Monitor reading (MultiSync EA234WMi)
% \usepackage[margin=0.5in, paperheight=19.9in, paperwidth=11.1in]{geometry} % 1080 x 1920 Monitor reading (Portrait MultiSync EA234WMi)


\setlength{\columnsep}{1in}
\setlength{\columnseprule}{1px}

\date{\mydate\today}

\title{NESTOR}
\author{Andrew Owen Martin}

\pagestyle{noweb}

\begin{document}
\maketitle
\tableofcontents

\section{Introduction}

NESTOR is three sets of nodes, retina, memory and matching.

\section{Canonical description}
Matching neurons are fully interconnected to all other matching neurons.
They are also fully connected to both receptor neurons and memory neurons.

The output [of matching neurons] will always consist of (parts of) the accepted spike trains.

Matching neurons both maintain and output hypotheses--`where' values--defining possible locations of the target pattern on the retina.

An active matching neuron will output its current hypothesis as a spike train; an inactive matching neuron will adopt a new hypothesis from the first spike train it receives and output this.

Matching neurons evaluate their hypothesis--`where' value--by comparing randomly selected micro-feature(s)--`what' information--from the memory and the corresponding `what' information from the retina. If the micro-features (the corresponding `what' values) are the same \ldots{} the matching neuron becomes active.

An active matching neuron initiates a spike train and retains its current hypothesis (its `where' value).

A neuron failing to discover the same microfeature will remain inactive and will adopt a new hypothesis encoded in a spike train arriving from other matching neurons.

[I]f the first spike train arrives from memory or retina, a matching neuron will simply output a spike train encoding the position defined by the input trains without further processing of changes to its [notional] state.

A matching neuron only stores the `where' information \ldots{} of an accepted spike train. 

If a neuron is in an active state, it will select for processing the first spike trains from the retina and memory such that $\Delta{}^{w}_{\text{ret}} + \Delta{}^{w}_{\text{mem}} = \Delta{}^{w}_{\text{neur}}$.

If the comparison is successful (i.e. the `what' of the memory neuron matches the `what' of the retina neuron) the matching neuron fires a spike train corresponding to the position defined by its hypothesis $\Delta{}^{w}_{\text{neur}}$.

Otherwise, the matching neuron will become inactive. In the inactive state the matching neuron will accept information from either the first arriving spike train from another matching neuron or spike trains memory and the retina (albeit with no constraints on ISI's). I think this means it does not wait for a pair of spike trains where the `where' parts add up to something specific.

If the first spike train comes from a retina and memory cell then it adds up the `where' parts and emits it. If the first spike comes from a matching cell then it will adopt the `where' part as its hypothesis and become active.

\section{Finite state machine}


So what are the actual states? Retina and memory cells just fire their position and feature, retina cells also update their feature. For matching cells I need a list of states, and a list of events.

States
\begin{enumerate}
\item No retina and no memory and inactive
\item Retina and no memory and inactive
\item No retina and memory and inactive
\item Retina and memory and inactive
\item About to fire and inactive
\item No retina and no memory and active
\item Retina and no memory and active
\item No retina and memory and active
\item Retina and memory and active
\item About to fire and active
\end{enumerate}

Events
\begin{enumerate}
\item Retina spike received
\item Memory spike received
\item Matching spike received
\item Time to fire equals zero
\end{enumerate}

\section{Inter-spike Interval (ISI)}
<<isi class>>=
ISI = namedtuple('ISI', ('position', 'feature'))
@

<<nestor classes>>=
<<isi class>>
@

\section{Cell classes}

\subsection{Cell class}
<<cell class>>=
class Cell:

	def __init__(self, id_num, where, what):
		self.id_num = id_num
		self.where = where
		self.what = what

	def __repr__(self):
		return 'cell'
@


<<nestor classes>>=
<<cell class>>
@
\subsection{Memory cell}
<<memory cell>>=
class Memory(Cell):

	name = 'memory'
@

<<nestor classes>>=
<<memory cell>>
@

\subsection{Retina cell}
<<retina cell>>=
class Retina(Cell):
	
	name = 'retina'
@

<<nestor classes>>=
<<retina cell>>
@

\subsection{Update retina function}
<<update retina function>>=
def update_retina(network, retina_features):
	for cell, feature in zip(network.retina, retina_features):
		cell.what = feature
@

<<nestor methods>>=
<<update retina function>>
@

\subsection{Process cell function}
<<process cell function>>=
def process_cell(cell, mean, sigma, min_wait, max_wait):
	while True:
		next_wait = max(
			min(random.gauss(mean,sigma), max_wait),
			min_wait)
		time.sleep(next_wait)
		for connection in cell.links:
			isi = (cell.name, cell.where)
			try:
				connection.receptor.put(isi,block=False)
			except queue.Full:
				isi = 'nothing'
		log.info('{n}#{num} fired {where} to all cells, next fire in {x:0.3f}s'.format(
			n=cell.name,
			num=cell.id_num,
			where=isi,
			x=next_wait))
@

<<dependencies>>=
import random
import sys
@

<<nestor methods>>=
<<process cell function>>
@

\subsection{Matching cell}
<<matching cell>>=
class Matching(Cell):

	name = 'matching'

	def __init__(self, id_num, where=None, what=None, hypothesis=None, receptor=None):
		super().__init__(id_num, where, what)
		self.hypothesis = hypothesis
		if receptor is None:
			receptor = Queue(maxsize=1)
		self.receptor = receptor
@

<<dependencies>>=
@

<<nestor classes>>=
<<matching cell>>
@

\subsection{Process matching cell}
<<process matching cell>>=
def process_matching(cell, mean, sigma, min_wait, max_wait):

	start_time = datetime.now()
	while True:
		signal = cell.receptor.get()

		log.info('cell {c} gets {s}'.format(c=cell.id_num,s=signal))
@

<<dependencies>>=
import time
import queue
@

<<nestor methods>>=
<<process matching cell>>
@

\section{Network}

\subsection{Network namedtuple}
<<network class>>=
Network = namedtuple('Network',('retina','memory','matching'))
@

<<nestor classes>>=
<<network class>>
@

\subsection{Make Network function}
<<make network function>>=
def make_network(retina_count, matching_count, memory_features):

	# Make retina cells
	retina_cells = [
		Retina(
			id_num=retina_num,
			where=retina_count - retina_num,
			what=None,)
		for retina_num
		in range(retina_count)
	]

	# Make memory cells
	memory_cells = [
		Memory(
			id_num=memory_num,
			where=memory_num,
			what=feature,)
		for memory_num, feature
		in enumerate(memory_features, start=1)
	]

	# Make matching cells
	matching_cells = [
		Matching(id_num=matching_num,)
		for matching_num
		in range(matching_count)
	]

	for retina in retina_cells:
		retina.links = matching_cells

	for memory in memory_cells:
		memory.links = matching_cells

	for num, matching in enumerate(matching_cells):
		others = matching_cells[:num] + matching_cells[num+1:]
		matching.links = others

	return Network(
		retina=retina_cells,
		matching=matching_cells,
		memory=memory_cells,)
@

<<nestor methods>>=
<<make network function>>
@

\subsection{Run network function}
<<run network function>>=
def run_network(network, start):

	matching_sleep = 0.1
	#sleep = 100

	cell_worker = partial(
		process_cell,
		mean=5,
		sigma=3,
		min_wait=0.1,
		max_wait=10)

	static_cell_processes = [
		Process(target=cell_worker, args=(cell,), daemon=True)
		for cell
		in chain(network.retina, network.memory)
	]

	matching_worker = partial(
		process_matching,
		mean=1,
		sigma=0.5,
		min_wait=0.1,
		max_wait=3,)

	matching_cell_processes = [
		Process(target=matching_worker, args=(cell,), daemon=True)
		for cell
		in network.matching
	]

	[process.start() for process in chain(
		static_cell_processes,
		matching_cell_processes,)]

	input()
@

<<dependencies>>=
from multiprocessing import Process, Queue
from functools import partial
from itertools import chain
@

<<nestor methods>>=
<<run network function>>
@

\section{Front end}
<<front end>>=
description = (
	"Run a NESTOR, mostly as a library" # Action of the script
)

if __name__ == '__main__':
	parser = argparse.ArgumentParser(
		description=description,
	)
	
	#parser.add_argument(
	#	"positional_arg",
	#	type=int,
	#	help="Integer positional argument",
	#)

	parser.add_argument(
		'-o','--optional',
		type=int,
		default=42,
		help="Integer keyword argument",
	)

	args = parser.parse_args()

	#print(args.optional)

	network = make_network(
		retina_count=5,
		matching_count=2,
		memory_features=('red','green','red'),)

	update_retina(
		network,
		('green','red','green','red','black'),)

	try:
		run_network(network,start=datetime.now())
	except KeyboardInterrupt:
		log.info('finished')
@

<<dependencies>>=
import argparse
@

\section{Library definition}
<<nestor.py>>=
#!/usr/bin/env python
# -*- coding: utf-8 -*-
<<dependencies>>
from collections import namedtuple
from datetime import datetime
from datetime import timedelta
from itertools import chain
import random
import time
<<init logging>>
<<nestor classes>>
<<nestor methods>>
<<front end>>
@

\subsection{Logging}
<<init logging>>=
log.basicConfig(level=log.INFO)
@

<<dependencies>>=
import logging as log
@

\appendix{}

\section{Index}

\nowebindex{}

\section{Code Chunks}

\nowebchunks{}

\end{document}

